### 第8章 对象引用、可变性和垃圾回收



##### 8.1 变量不是盒子

```
python中一切皆对象，变量只是对象的引用或者别名、或者说变量是对象的标注，可以有很多标注指向一个对象。
```

```python
>>> a = [1,2,3,4]
>>> b = a			# b是变量a的引用，变量a和b引用同一个对象
>>> a.append(5)
>>> a
[1, 2, 3, 4, 5]
>>> b
[1, 2, 3, 4, 5]		# 修改a, b也随之修改
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'b']

>>> id(a)			# id() 取地址
2118862476232
>>> id(b)
2118862476232		# 变量a和b指向同一个地址，指向同一个list对象
```



##### 8.2.1 == 和 is

**==**比较两个对象的值(对象中保存的数据)， **is** 比较对象的标识 (类似于地址)。

多数情况我们只关注变量的值， == 用的更多

is运算符比 == 速度快。因为is内置运算符不能重载，python不用寻找并调用特殊方法，而是直接比较id()

而a==b 等同于a.__ eq __(b)



##### 8.2.2 元组的相对不可变性 （元组中存放的对象的引用不可变）

首先，元组和其他数据结构一样，保存的是**对象的引用**

python3中有6种基本数据类型

- Number（数字）
- String（字符串）
- List（列表）
- Tuple（元组）
- Set（集合）
- Dictionary（字典）

其中，Python3 的六个标准数据类型中：

- **不可变数据（3 个）：**Number（数字）、String（字符串）、Tuple（元组）；
- **可变数据（3 个）：**List（列表）、Dictionary（字典）、Set（集合）。

Tuple(元组) 指的是 ！**数据不可变**！ 即**元组的不可变性是指元组中保存的引用不可变。**

**不可变的是元素的标识**

示例 8-5：

```python
>>> t1 = (1,2,3,[1,2,3])
>>> t2 = (1,2,3,[1,2,3])
>>> t1 == t2
>>> True
(1, 2, 3, [1, 2, 3])	
>>> id(t1[-1])			
2118862477128
>>> t1[-1].append(99)
>>> t1
(1, 2, 3, [1, 2, 3, 99])
>>> t1 == t2
False
>>> id(t1[-1])
2118862477128			# t1不可变，但是t1[-1]的数据可变，因为t1[-1]指向的是对列表[1,2,3]的引用，一直没变
```



##### 8.2.1 默认做浅复制

python中的浅拷贝、深拷贝、引用赋值

**浅拷贝**   副本是源数据现有对象的引用，源数据新增的对象与副本无关！

```python
>>> l1 = [3, [55,44], (7,8,9)]
>>> l2 = list(l1)			# list(l1) 创建l1的副本 浅拷贝赋值给l2
>>> l2
[3, [55, 44], (7, 8, 9)]
>>> l2 == l1
True
>>> l2 is l1			# 副本与源列表值相同，但指代不同的对象
False
>>> l1[-2].append(-1)
>>> l1
[3, [55, 44, -1], (7, 8, 9)]
>>> l2
[3, [55, 44, -1], (7, 8, 9)]		# 浅拷贝：l1源列表中已存在的对象赋值给l2，若l1的对象值改变，l2也跟着改变。但l1新增的对象和l2无关
>>> l1.append('111')
>>> l2
[3, [55, 44, -1], (7, 8, 9)]	# l2的值并没变化
```

**深拷贝** 就是重新开辟内存空间的新对象，和源数据没任何关系，新生命 

```python
import copy

>>> import copy
>>> a = [1,2,3,[4,5],(6,7,8)]
>>> a
[1, 2, 3, [4, 5], (6, 7, 8)]
>>> b = copy.copy(a)			# 浅拷贝！
>>> b
[1, 2, 3, [4, 5], (6, 7, 8)]
>>> b
[1, 2, 3, [4, 5], (6, 7, 8)]
>>> c = copy.deepcopy(a)		# 深拷贝
>>> c
[1, 2, 3, [4, 5], (6, 7, 8)]
>>> a.append([12,13])
>>> c
[1, 2, 3, [4, 5], (6, 7, 8)]
```

**引用赋值** 就是别名，副本和源地址指向同一地址，同变化

**列表的删除方法：**

1、`list.remove(obj) `

移除列表中某个值的第一个匹配项

```python
[2, 3, (2, 3, 4), [0, 2, 1]]
>>> l1.append(2)
>>> l1.append(3)
>>> l1
[2, 3, (2, 3, 4), [0, 2, 1], 2, 3]
>>> l1.remove(2)
>>> l1
[3, (2, 3, 4), [0, 2, 1], 2, 3]
```

2、`list.pop(index=-1)`

根据index索引移除列表中的元素(默认最后一个元素)， 并返回该元素的值

3、`del list[2]` 删除第三个元素

```python
del list[-1] # 删除最后一个元素
```



##### 8.4 函数的参数作为引用时

python函数的形参通过引用方式传参，即形参是实参的别名。

函数中对形参的操作可能会影响在外部传入的实参。（但数字、元组不会改变）

